---
created: 2024-12-26T00:00:00+03:00
modified: 2025-05-15T11:24:00+03:00
aliases:
  - C++
  - cpp
  - си плюс плюс
category:
  - "[[Программирование]]"
---

# C++

## Фичи

[Источник](https://habr.com/ru/articles/847996/)

### Выделенный инициализатор

При помощи выделенных инициализаторов вы можете указывать, какие именно элементы объекта (массива, структуры, объединения) должны инициализироваться следующими значениями. Порядок неважен!

```c
struct Foo {
  int x, y;
  const char *bar;
};

void f(void) {
  int arr[] = { 1, 2, [5] = 9, [9] = 5, [8] = 8
};

  struct Foo f = { .y = 23, .bar = "barman", .x = -38 };

  struct Foo arr[] = {
    [10] = { 8, 8, 9 },
     [8] = { 1, 8, bar3 },
    [12] = { .x = 9, .z = 8 },
  };

  struct {
    int sec, min, hour, day, mon, year;
  } z = {
    .day = 31, 12, 2014,
    .sec = 30, 15, 17
  }; // инициализирует z в { 30, 15, 17,  31, 12, 2014 }
}
```


>[!note]- Источники
>- https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html
>- https://www.ibm.com/docs/en/zos/2.5.0?topic=initializers-designated-aggregate-types-c-only
>- https://stackoverflow.com/q/47202557/10247460


### Составные литералы

Составной литерал выглядит как приведение списка инициализаторов, заключённого в скобки. Его значение — это объект того типа, что указан при приведении, и в нём содержатся элементы, указанные в инициализаторе.

```c
#include <stdio.h>

struct Foo { int x, y; };

void bar(struct Foo p) {
  printf("%d, %d", p.x, p.y);
}

int main(void) {
  bar((struct Foo){2, 3});
  return 0;
}
```

>[!note]- Источники
>- https://gcc.gnu.org/onlinedocs/gcc/Compound-Literals.html


### Защита от затенения

Следующий код вернёт 42, а не 3840!

```c
int x = 42;

int func() {
  int x = 3840;
  {
    extern int x;
    return x;
  }
}
```


### Многосимвольные константы

Они зависят от реализации и даже от самого стандарта, так что обычно лучше их избегать. При этом они достаточно удобны в качестве самодокументируемых перечислений, если впоследствии вам придётся иметь дело с необработанными дампами памяти.

```c
enum state {
  waiting = 'WAIT',
  running = 'RUN!',
  stopped = 'STOP',
};
```

Например, у меня на машине я могу локализовать 'WAIT' как показано здесь:

```
00001120: c3 66 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 40 00  .ff...........@.
00001130: f3 0f 1e fa e9 67 ff ff ff 55 48 89 e5 48 83 ec  .....g...UH..H..
00001140: 10 c7 45 fc 54 49 41 57 8b 45 fc 89 c6 48 8d 05  ..E.TIAW.E...H..
00001150: b0 0e 00 00 48 89 c7 b8 00 00 00 00 e8 cf fe ff  ....H...........
00001160: ff b8 00 00 00 00 c9 c3 f3 0f 1e fa 48 83 ec 08  ............H...
```


### Битовые поля

Объявляется член с явно заданной шириной в битах. Прилегающие к нему члены битового поля могут быть упакованы для совместного использования и растягивания отдельных битов.

```c
struct cat {
  unsigned int legs : 3;  // 3 бита на лапы  (0-4 умещается в 3 бита)
  unsigned int lives : 4;  // 4 бита на жизни (0-9 умещается в 4 бита)
};
```

>[!note]- Источники
>- https://en.cppreference.com/w/c/language/bit_field
>- https://en.wikipedia.org/wiki/Bit_field
>- https://stackoverflow.com/q/24933242/10247460


### "оператор" -->

Следующий код на C корректен:

```c
size_t n = 10;
while (n --> 0) {
  printf("%d\n", n);
}
```

Уместен вопрос: с каких это пор в C есть такой оператор? И я отвечу: ни с каких. --> - это не один, а два разных оператора, -- и >, записываемых друг за другом. Поэтому они выглядят как один. Это допустимо, поскольку C снисходительно относится к пробелам.

n --> 0 эквивалентно (n--) > 0


### idx[arr]

Нотация с квадратными скобками для обращения к элементам массива – это синтаксический сахар, применяемый в арифметике указателей:

```c
arr[5] ≡ *(arr + 5) ≡ *(5 + arr) ≡ 5[arr]
```

Категорически недопустимо использовать такое в реальном коде... а вообще выглядит довольно забавно!

```c
// массив[индекс]
boxes[products[myorder.product].box].weight;

// индекс[массив]
myorder.product[products].box[boxes].weight;
```


### Отрицательные индексы массива

Однажды, когда мне требовалось по-быстрому провести отладку, я решил проверить, корректными ли значениями заполнено пространство в конце массива. Но я не знал, откуда именно начинается заполнение. Поэтому я сделал так:

```c
int *end = arr + (len - 1);
if (end[0] == VAL && end[-1] == VAL && end[-5] == VAL) {
  puts("Correct padding");
}
```


### Конкатенация строковых литералов

Вам не требуется ни sprintf() (ни strcat()!) для конкатенации строковых литералов:

```c
#define WORLD "World!"
const char *s = "Hello " WORLD "\n"
                "It's a lovely day, "
                "innit?";
```


### Именованные параметры функций

```c
struct _foo_args {
  int num;
  const char *text;
};

#define foo(...) _foo((struct _foo_args){ __VA_ARGS__ })
int _foo(struct _foo_args args) {
  puts(args.text);
  return args.num * 2;
}

int main(void) {
  int result = foo(.text = "Hello!", .num = 8);
  return 0;
}
```


### Сочетание аргументов по умолчанию, именованных и позиционных аргументов

Используем составные литералы и макросы для создания именованных аргументов:

```c
typedef struct { int a,b,c,d; } FooParam;
#define foo(...) foo((FooParam){ __VA_ARGS__ })
void (foo)(FooParam p);
```

Добавить аргументы по умолчанию также не составляет труда:

```c
#define foo(...) foo((FooParam) { .a=1, .b=2, .c=3, .d=4, __VA_ARGS__})
```

Но после этого позиционные аргументы перестанут действовать; кроме того, могут возникать ситуации, в которых вам захочется поддерживать оба варианта. Но недавно я обнаружил, что можно заставить такие комбинации работать, добавив формальный параметр:

```c
typedef struct { int _; int a,b,c,d; } FooParam;
#define foo(...) foo((FooParam){ .a=1, .b=2, .c=3, .d=4, ._=0, __VA_ARGS__})
```

Теперь foo можно вызывать следующими способами:

```c
foo();           // a=1, b=2, c=3, d=4
foo(.a=4, .b=5); // a=4, b=5, c=3, d=5
foo(4, 5);       // a=4, b=5, c=3, d=5
foo(4, 5, .d=8); // a=4, b=5, c=3, d=8
```

Формальный параметр не требуется, если у вас есть аргументы, которые требуется передавать по имени:

```c
typedef struct { int alwaysNamed; int a,b,c,d; } FooParam;
#define foo(...) foo((FooParam){.a=1,.b=2,.c=3,.d=4, .alwaysNamed=5, __VA_ARGS__})
```

